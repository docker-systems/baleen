from django.db import models

from baleen.utils import ManagerWithFirstQuery
from baleen.artifact.models import output_types, ActionOutput

class Hook(models.Model):
    """
    Hooks for success/failure/finished during a build, as
    well as arbitary events.

    """
    project = models.ForeignKey('project.Project')
    # actions can choose to implement any "event", and you can make the hook wait
    # for that.
    watch_for = models.CharField(max_length=255,
            help_text="The event to watch for, can be anything.")

    # Email a user, a particular email address, or the commit author
    email_user = models.ForeignKey('auth.User')
    email_address = models.EmailField(max_length=255)
    email_author = models.BooleanField(default=False)
    
    # Post details about the event
    post_url = models.URLField()

    def activate(self, *args, **kwargs):
        pass


class WaitingFor(models.Model):
    """
    Define a model for tracking when a project is waiting on another
    one to complete.

    Need to remove all waitingfor objects for a project when the project
    is synced with github.
    """
    project = models.ForeignKey('project.Project')
    waiting_for = models.ForeignKey('action.BuildDefinition',
            related_name='blocking_projects')


class BuildDefinition(models.Model):
    """
    A build definition is a file in the repo that is parsed to work out
    how to build the project.

    It is used to generate an ActionPlan.
    """
    project = models.ForeignKey('project.Project')
    #updated_at = models.DateTimeField(
            #help_text='The source commit hash this build definition came from')
    commit = models.CharField(max_length=255, null=True, blank=True,
            help_text='The source commit hash this build definition came from')
    filename = models.CharField(max_length=255, null=True, blank=True,
            help_text='Filename will probably help determine what the format is') 
    raw_plan = models.TextField(null=True, blank=True)
    plan_type = models.CharField(max_length=255, null=True, blank=True) 

    def save(self):
        if self.plan_type is None:
            self.plan_type = self.detect_plan_type(self.filename, self.raw_plan)
        super(BuildDefinition, self).save()

    def detect_plan_type(self, filename, raw_plan):
        # assume it's docker until we support new types
        return 'docker'


class ActionResult(models.Model):
    """
    When an Action is run, an ActionResult is created.

    This stores the start time, and when the action finishes, stores the end time
    and status code (0 implies success).

    Any output generated by an action is stored in ActionOutput instances which
    link to an instance of this class.
    """
    job = models.ForeignKey('job.Job')

    action = models.CharField(max_length=255)

    started_at = models.DateTimeField()
    finished_at = models.DateTimeField(null=True)

    status_code = models.IntegerField(null=True)

    message = models.TextField(blank=True)

    objects = ManagerWithFirstQuery()

    def __unicode__(self):
        return "%s" % self.action.name

    def save(self):
        super(ActionResult, self).save()

    @property
    def success(self):
        return self.status_code == 0

    @property
    def in_progress(self):
        return self.started_at and self.finished_at is None and self.status_code is None

    @property
    def has_output(self):
        return self.actionoutput_set.count() > 0

    @property
    def stdout(self):
        return self.get_output(output_types.STDOUT)

    @property
    def stderr(self):
        return self.get_output(output_types.STDERR)

    @property
    def duration(self):
        if self.in_progress:
            return None
        return self.finished_at - self.started_at

    def get_output(self, output_type):
        try:
            return self.actionoutput_set.get(output_type=output_type)
        except ActionOutput.DoesNotExist:
            pass
